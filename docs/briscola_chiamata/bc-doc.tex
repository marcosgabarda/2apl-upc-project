%%% compile it with pdflatex
\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{fancybox}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{amssymb}
\usepackage{amsmath}

\begin{document}

\title{A Multi-Agent System for\\ playing Briscola Chiamata}
 
\author{Beltran Borja Fiz, Fabrizio De Santis, Marcos Gabarda\\
\small \texttt{\{beltran.borja.fiz, fabrizio.de.santis, marcos.gabarda\}@est.fib.upc.edu}\\
\\
Multi-Agent Systems Course\\
Master in Artificial Intelligence\\
Universitat Polit\`ecnica de Catalunya}
\date{\today}

\newenvironment{fminipage}%
  {\begin{Sbox}\begin{minipage}}%
  {\end{minipage}\end{Sbox}\fbox{\TheSbox}}

\maketitle

\tableofcontents

\newpage

\section{Introduction}\label{sec:intro}

2-APL stands for A Practical Programming Language , and is developed at the University of Utrecht as an academic tool for developing intelligent multi-agent systems. With its unique feature of integrating a declarative and an imperative style programming and the ability to use the JADE platform, 2APL is a resourceful environment to program in.

In a previous Paper we described the features of 2APL, along with a more formal description of the language. Its tools were presented and a few examples were showcased to see some agents in action.The aim of this Paper is to present our own prototype of a 2APL multiagent system to model the card game of Briscola Chiamata. 

There are many features that make Briscola Chiamata an ideal game to model with a multiagent system. The way the game works forces the developer to give agents cooperation, while at the same time being competitive; they have to be reactive, but also proactive; finally they need to also be autonomous and social.

Cooperation in Briscola Chiamata is a double-edge sword, since if you choose the wrong player to cooperate with, you will be the cause of your own defeat. On the other hand, a successful cooperation will most of the time ensure a safe victory. This risk in choosing who to trust and cooperate with is what makes the game exciting for humans, and hard for agents.Competition is divided into two types, an individual agent competing to win the game, and a team of agents, trying to compete against the opposite team.

Reactivity is an obvious requirement in any group game; when it is your turn to play, you have to play. In Briscola Chiamata however a Proactivity is also required since players need to bid only if they desire and the turns are non strict, i.e: a player can decide to play outside his turn. This freedom of the game needs to be given to the agents.

The social factor comes from the fact that players have to interact with each other in order to advance the game. The bidding system each round of the game and the fact that teams are created without the agents knowing who they are partners with creates the necessity for communication between them in order to try and determine who this partner is. Having agents change status from partner to opponent between rounds makes a dynamic social multiagent system which is worth studying.

The rest of the report is organized as follows. Section~\ref{sec:gamedescr} a description of the game. In the next sections we follow the Prometheus design methodology to create our system where the the System Specification phase is illustrated in Section~\ref{sec:sysspec}, the High-level (Architectural) Design in Section~\ref{sec:highdesign} and Detailed Design in Section~\ref{sec:detaildesign}. Finally, we display the built prototype in Section~\ref{sec:proto} and we conclude the paper in Section~\ref{sec:concl} with some remarks, related works and conclusions on the overall success of the prototype.

\section{Game Description}\label{sec:gamedescr}

Briscola Chiamata is the five-player version of Briscola. Every player is dealt eight cards, so that no cards remain undealt. Then, each player, starting from the dealer's right\footnote{If the dealer is not one the players, then starting from the declearer's right.} and proceeding counter-clockwise, bids in an auction to declare how many points they will score. A player may pass, and hence cannot bid again in that game. The bid represents the number of points that player believes he is capable of accumulating. Bidding continues until all but one player have passed in a round. This remaining player has then "won the bid" and therefore gets to declare the Briscola. The declarer also declares a specific Briscola card (example, the ``Ace of Cups'' if Cups was the declared Briscola) and the holder of this card is then determined to be the declarer's partner. Logically, the declarer would declare the highest Briscola card he does not already hold in the hopes of creating the strongest combined hand between him and his partner.
The remaining three players are partnered with each other, without their knowledge. Each player, other than the declarer's partner, acts independently, until it is clear which players are partners. Infrequently, the declarer may declare a Briscola card he already holds (if he feels he has a very strong hand), in which case the other four players are partenered against him.
Game strategy is often devised to determine which player is partnered with the declarer, whereas the declarer's partner may devise ruses and decoy strategies to fool the other players, such as not taking a trick, or playing points on a trick that will be won by an opponent.

\paragraph{Scoring}

Each player collects tricks as per the regular version of the game, and counts points collected similarly. Partners, which are known by the end of the game, then combine their points. Game points are assigned as follows: if the declarer and partner accumulate card points greater than or equal to the points that were declared after the bidding process, then the declarer earns two game points, the partner earns one game point and the other players each lose one game point. If the declarer and partner accumulate fewer card points than declared, then  the declarer loses two game points, the partner loses one game point and the other players each earn one game point. These points are accumulated after every game. The grand winner is the player with the most points at the end of the last match. Note that if the declarer calls a Briscola he holds, then the declarer will win or lose four points, and every other player will win or lose one point.

\section{System Specification}\label{sec:sysspec} 

In this phase, actors (human or software) expected to interact with the system, are identified, along with the interface to the system in terms of actions and percepts; system goals are elaborated, and scenarios described in terms of sequences of steps are developed. Roles encompassing small chunks of functionality (identified by goals, percepts and actions) are described and captured.

\subsection{Analysis Overview Diagram}

The analysis overview diagram is designed to show the interactions between the system and the environment. At this abstract level it is necessary to identify the actors, scenarios, percepts and actions involved in the system. This consists of a two step process. Firstly, we identify the actors and the scenarios they participate in with the system. Secondly, we identify and define the actions and percepts between the actors and the system. Figure~\ref{fig:analysis} provides the analysis overview diagram for our game.

\begin{figure}[htp]
  \includegraphics[keepaspectratio,scale=0.35]{pdt/images/system_specification/analysis_overview.png}
  \label{fig:analysis}
  \caption{Analysis overview diagram}
\end{figure}

The actors are the people or all external systems associated with the system that  we can model in our game as the User of the system. The scenarios are the processes which the system uses to handle the percepts and produce the actions. The percepts are all the types information which come into the system from the environment. The actions is everything that is sent from the system to the environment.

Here follows a brief description of each of them: 
\begin{itemize}
  \item ``Start the game Scenario'' is in charge of receveing join requests from users and accept and subscribe users or queue their requests. Once there are 5 players registered in the system.
  \item ``Dealing scenario'' is in charge of choosing the dealer, shuffle the deck and deal cards to all subscribed the players in the system. 
  \item ``Bidding scenario'' takes place once the dealing is over. It is in charge of giving players a chance to bid. The player who wins the bid, must declare the Briscola card. If nobody bids, then the game has to be restarted. If the bidding succeeds, the Briscola card is declared by the winner of the bid.
  \item ``Play the game'' scenario occurs once all bids are over and the game finally starts. The team distributions are obviously unknown to all players until the Briscola card is played. The players have to update their beliefs about the team distributions each time a card is played. Of course, cheating is part of the game. Communication that is used to model sign exchange among players is allowed to exchange information about players and cards. After each round, points are counted. 
  \item ``End of the game'' scenario is in charge of declaring the winner team, update the score of each player according to the scoring rules and release the player from the system. 
\end{itemize}

Finally, percepts and actions in the system are summarized in Table~\ref{table:inout}.

\begin{table}[htp]
  \begin{tabular}{|l|l|}
    \hline
    Join request	& Subscribe user and manage request  \\
    \hline
    5 players in the system	& Choose the card dealer, shuffling and dealing cards  \\
    \hline
    Dealing is over	& Start bidding in turn \\
    \hline
    Bidding is over	& Declare the Briscola card \\ 
    \hline
    Briscola declared	& Start playing in turn \\
    \hline
    Card played	& Update internal beliefs about teams setting \\
    \hline
    Message from other players & Update internal beliefs about teams setting \\
    \hline
    The hand is over	& Count points \\
    \hline
    The game is over	& Declare the winner \\
    \hline
    Winner declared	 & Update the system scoring \\
    \hline
    System scoring updated	& Release the agents from the system \\
    \hline
  \end{tabular}
  \label{table:inout}
  \caption{Summary of percepts and actions in the system}
\end{table}

\subsection{Scenarios Diagram}

The scenarions diagram provided in Figure~\ref{fig:scenarios} shows the dynamics of the game. The scenarios cover all the phases of the game. First, the ``start the game scenario'' waits for players to register in the system, then the ``dealing scenario'' deals cards to the players, after that the ``bidding scenario'' allows the players to do their bids, then ``play the game scenario'' allows them to play the gam and finally the ``end the game scenario'' assigns them their socre. If nobody of the players leave the system, another game can be started, again from the ``dealing scenario''.

\begin{figure}[htp]
  \includegraphics[keepaspectratio,scale=0.5]{pdt/images/system_specification/scenarios.png}
  \label{fig:scenarios}
  \caption{Scenarios diagram}
\end{figure}

\subsection{Goals Diagram}

The goal overview diagram is a directed acyclic graph of all goals in the system showing how goals can be decomposed into subgoals. Sub-goals can be generated by asking ``how will the system accomplish this goal'' Parent goals can be generated by asking ``why does the system accomplish this goal''. Figure~\ref{fig:goals} shows our goals diagram for the game.

\begin{figure}[htp]
  \includegraphics[keepaspectratio,scale=0.4]{pdt/images/system_specification/goal_overview.png}
  \label{fig:goals}
  \caption{Goals diagram}
\end{figure}
  
\subsection{System Roles Diagram}

The next stage of the process is to group similar goals together into roles. Each role should be limited in scope, and be able to be described fully be 1-2 sentences. In a system roles diagram, we group different goals, percepts and actions under roles. This helps in further modularizing the system into functionality. The input is represented as a percept and the output as an action. Figure~\ref{fig:sysroles} shows our system roles diagram for the game. As stated, the description of each role can be given in a short sentence and they are quite obvious. The ``starting game role'' manages join requests, ``identify the dealer role'' identifies the dealer in the system, ``dealing role'' shuffle and deal cards, ``bidding role'' manage bids, ``declaring briscola role'' is used to declare the briscola card, ``turn control role'' decides player's turn to play, ``playing role'' is used to play cards, ``team setting role'' try to infer team settings, ``counting points role'' counts points for each rounds, ``declare the winner role'' declares the winner team of the game, ``update score points'' updates the score table while ``release the player'' release the players from the system. 

\begin{figure}[htp]
  \includegraphics[keepaspectratio,scale=0.4]{pdt/images/system_specification/system_roles.png}
  \label{fig:sysroles}
  \caption{System roles diagram}
\end{figure}

\section{High-level (Architectural) Design}\label{sec:highdesign}

In this phase, the agent types that will exist in the system are defined by combining roles, the overall structure of the system is described using a system overview diagram, and interaction protocols are used to capture the dynamics of the system in terms of legal message sequences.

\subsection{Data Coupling Diagram}

The roles that were formed in the last step of the previous phase are linked to data that has been identified as necessary for performing that role. In the data-coupling diagram you can see all roles and data types in the system. The following data types have been identified in the system: ``position'' that record the position of the player at the table that is useful to decide its turn, the ``deck'' that contains all the cards, the ``hand'' that represents the cards in hand of each player, the ``historic of bids'' that records the historic of bids, the ``historicic of card played'' that analogusly records the historic of card played in order to decide which card to play, the ``team information'' that is used to store beliefs about team settings, the ``points'' that is used to store the points of each round and finally the ``scoreboard'' that contains the all the times score of the games for each player. The data coupling diagram is provided in Figure~\ref{fig:datacoupl}.

\begin{figure}[htp]
  \includegraphics[keepaspectratio,scale=0.45]{pdt/images/architectural_design/data_coupling.png}
  \label{fig:datacoupl}
  \caption{Data coupling diagram}
\end{figure}

\subsection{Agent-Role Grouping Diagram}

In this diagram we group the roles into agent types. Decisions regarding how to group depend on role similarity, as well as analysis of data usage. The agent-role coupling diagram shows the group of roles that come under an agent. The ``dealer'' agent type represents the dealer that is in charge of dealing cards. The ``gatekeeper'' agent type represents the agent that let the players come in and out the system. The ``non-player charcter'' agent types represents the actual players in the system. Finally the ``notary'' agent type represents the agent in charge of controlling the game. Figure~\ref{fig:agentrole} provides the agent-role grouping diagram for our game.

\begin{figure}[htp]
  \includegraphics[keepaspectratio,scale=0.45]{pdt/images/architectural_design/aget-role_grouping.png}
  \label{fig:agentrole}
  \caption{Agent-role grouping diagram}
\end{figure}

\subsection{Agent Acquaintance Diagram}

In the agent acquaintance diagram you can see all agents within the system and which agents interact. The agent acquaintance diagram is provided in Figure~\ref{fig:agentacq}. 

\begin{figure}[htp]
  \includegraphics[keepaspectratio,scale=0.45]{pdt/images/architectural_design/agent_acquaintance.png}
  \label{fig:agentacq}
  \caption{Agent acquaintance diagram}
\end{figure}

\subsection{System Overview Diagram}

In the system overview diagram you can see all agents in the system, along with their interface and interactions. The system overview diagram is provided in Figure~\ref{fig:sysovervw}.

\begin{figure}[htp]
  \includegraphics[keepaspectratio,scale=0.45]{pdt/images/architectural_design/system_overview.png}
  \label{fig:sysovervw}
  \caption{System overview diagram}
\end{figure}

\section{Detailed Design}\label{sec:detaildesign}

In this phase, the internals of each agent are developed in terms of capabilities, events, plans and data. Detailed Design is done at the level of individual agents.

\subsection{Agent Overview Diagram}
The agent overview diagram shows the internals of an agent. There is one agent overview diagram for every agent in the system: the dealer, the gatekeeper, the 5 non-player character and the notary. Diagrams for each of them are provided in Figure~\ref{fig:dealer}, Figure~\ref{fig:notary}, Figure~\ref{gatekeeper} and Figure~\ref{fig:nonplay-char}.

\begin{figure}[htp]
  \includegraphics[keepaspectratio,scale=0.45]{pdt/images/detailed_design/dealer_overview_diagram.png}
  \label{fig:dealer}
  \caption{Agent overview diagram for the dealer agent}
\end{figure}
\begin{figure}[htp]
  \includegraphics[keepaspectratio,scale=0.45]{pdt/images/detailed_design/notary_overview_diagram.png}
  \label{fig:notary}
  \caption{Agent overview diagram for the notary agent}
\end{figure}
\begin{figure}[htp]
  \includegraphics[keepaspectratio,scale=0.45]{pdt/images/detailed_design/gatekeeper_overview_diagram.png}
  \label{fig:gatekeeper}
  \caption{Agent overview diagram for the gatekeeper agent}
\end{figure}
\begin{figure}[htp]
  \includegraphics[keepaspectratio,scale=0.45]{pdt/images/detailed_design/non-player_character_overview_diagram.png}
  \label{fig:nonplay-char}
  \caption{Agent overview diagram for the non-player character agent}
\end{figure}
  

\subsection{Capability Overview Diagram}
The capability overview diagram allows you to specify the internals of a capability in terms of plans, or sub-capabilities and messages between them. Figure~\ref{fig:dealing-cap} provides the capabilities for the dealer agent, Figure~\ref{fig:notary-cap} for the notary agent, Figure~\ref{fig:gatekeeper-cap} for the gatekeeper agent and Figure~\ref{fig:non-player-cap} for the non-player character agent, 

\begin{figure}[htp]
  \includegraphics[keepaspectratio,scale=0.45]{pdt/images/detailed_design/dealing_capability_overview_diagram.png}
  \label{fig:dealer-cap}
  \caption{Capability overview diagram for capabilities of the dealer agent}
\end{figure}
\begin{figure}[htp]
  \includegraphics[keepaspectratio,scale=0.45]{pdt/images/detailed_design/turn_selection_capability_overview_diagram.png}
  \includegraphics[keepaspectratio,scale=0.45]{pdt/images/detailed_design/end_the_game_capability_overview_diagram.png}
  \includegraphics[keepaspectratio,scale=0.45]{pdt/images/detailed_design/start_dealing_capability_overview_diagram.png}
  \includegraphics[keepaspectratio,scale=0.45]{pdt/images/detailed_design/control_bidding_capability_overview_diagram.png}
  \includegraphics[keepaspectratio,scale=0.45]{pdt/images/detailed_design/count_points_capability_overview_diagram.png}
  \label{fig:notary-cap}
  \caption{Capability overview diagram for capabilities of the notary agent}
\end{figure}
\begin{figure}[htp]
  \includegraphics[keepaspectratio,scale=0.45]{pdt/images/detailed_design/release_player_capability_overview_diagram.png}
  \includegraphics[keepaspectratio,scale=0.45]{pdt/images/detailed_design/join_players_capability_overview_diagram.png}
  \label{fig:notary-cap}
  \caption{Capability overview diagram for capabilities of the gatekeeper agent}
\end{figure}
\begin{figure}[htp]
  \includegraphics[keepaspectratio,scale=0.45]{pdt/images/detailed_design/receive_a_hand_capability_overview_diagram.png}
  \includegraphics[keepaspectratio,scale=0.45]{pdt/images/detailed_design/bidding_capability_overview_diagram.png}
  \includegraphics[keepaspectratio,scale=0.45]{pdt/images/detailed_design/declare_briscola_capability_overview_diagram.png}
  \includegraphics[keepaspectratio,scale=0.45]{pdt/images/detailed_design/playing_capability_overview_diagram.png}
  \includegraphics[keepaspectratio,scale=0.45]{pdt/images/detailed_design/join_to_game_capability_overview_diagram.png}
  \label{fig:non-player-cap}
  \caption{Capability overview diagram for capabilities of the non-player character agent}
\end{figure}

\section{Prototype}\label{sec:proto} 

The Prototype was built following the Prometheus design, and as described in the previous sections, each step was carefully defined, built and implmented. The idea was to use as many features as 2APL as possible, and thus our own personal environment was also created for this Paper.The prototype can therefore be logically separated in two parts : Firstly the environment in which the agents interact, and secondly the agents themselves.

Environments in 2APL, as previously mentioned, are created as a Java class extension. By using the example environment given in the documentation of 2APL we were able to build our own graphic user interface to allow researchers to see the agents in action. This environment was built so that it would allow agents to interact in all of the possible manners defined during the design stage, but also to manage the addition and removal of agents. We succesfully implemented it and achieved the desired level of detail as to be pleasing to the eye but not a burden to the real task at hand : the way the agents act and interact. A screenshot of the GUI can be seen in figure 6.1 . As you can see it was decided to split the program into three panels : The left panel being the one which shows each players cards, score and bid; a top right corner in which cards played are shown, and a bottom right panel in which information about the agent interactions is displayed, along with game information.

The Agents were designed separetely using prolog, and saved in separate files depending on the strategy they were programmed to have. Since there are five players in a Briscola Chiamata game, we were able to have up to five agents having different strategies fighting against each other and we would be able to see the victorious strategy. Even though prolog is mainly used to create the Agent, it is of limited use in the belief base and the usage of extra libraries could give the user more freedom when designing them (and  stronger strategies too). In figure 6,2 you can see a sample agent that was used in our prototype along with its settings.

The prototype however, as its name indicates, is marely a prototype and thus implements the most simplistic aspects . The agents were implemented to follow straight forward strategies with very little cooperation and even "cheating" in order to find their partners during a game round. It is worth mentioning that during the testing part, the 2APL parser was in most cases completely uselesss as the error messages it provides as feedback are unclear and unhelpful. This makes the task of perfectioning the prototype hard and tidious. Finally it is worth mentioning that this prototype was built so that it could easely be extended.For example it could be extended into an application which accepts both human and agent players, and even further to be played using a network and/or the internet in order to fight other agents.

We would have loved to add some of those more advanced features such as having completely radical strategies fighting each other, or even some form of reinforcement learning would have been fantastic to see in action, but time and the difficulty of extending things in 2APL have made it impossible have made this impossible.


\section{Conclusion}\label{sec:concl} 

The general feeling after implementing the briscola game into the 2APL system is both good and bad. I will start with the positive aspects.

Having a declarative programming when developing agents certainly gives the designer more freedom and a certain level of confidence that you would not have with other languages. You can focus specifically on 'what' you want your agents to do and not 'how'. This conceptual division is one of the main attractions of 2APL and even though some of us required to learn this type of programming in more depth as we had no previous experience in it, we certainly appreciated the benefit gained when we were in the implementation stage.

The JADE platform tools and some of 2APL tools were certainly helpful from beginning to end and provided us with information that would have otherwise been hard to see or find. Of course we can connect any of our agents to any other agent in the JADE platform and having portability is a helpful and important feature.

The negative aspects of 2APL are few, but certainly big. Firstly it is clearly a tool for research and not for real development. The documentation for 2APL has been ignored by its developers for far too long, it is simplistic , undetailed and the examples shown are ...one (which is not even fully explained!).The environment we built was done by scanning the code of some of the java classes of an example and thus we lacked the true ability to implement a full application (this was never our intention, but knowing that if you wanted it would be very difficult certainly isnt a positive aspect).

Even though prolog does give us a very powerful logic system, it does lack other tools such as databases, load data and other form of operation in which a prolog library would be required (and not allowed in 2APL).Finally, even though it was previously mentioned, the 2APL parser was so unhelpful that it barely provided us with any useful information. Clearer instructions or error messages would be necessary if any serious development was to be made in this language.

So even though we praised 2APL for some things and despised it for others, as a whole we were pleased to develop with 2APL and do believe that with more work it can become the "go to" language of multiagent systems... at least from a research point of view.


\section{Bibliography}
\nocite{*}
\bibliographystyle{plain}
\bibliography{bc-doc}

\end{document}
