BeliefUpdates:
  { true }  SetAssigned(POS, X)  { assigned(POS, X) }
  { true }  RemoveAssigned(POS, X) 	{ not assigned(POS, X) }
  { true }  SetDealer(X)  { dealer(X) }
  { not currentturn(_) }  UpdateTrun(X)  { currentturn(X) }
  { currentturn(X) }  RemoveTrun(X)  { not currentturn(X) }
  { true }  PlayerPass(X)  { playerpass(X) }
  { true }  AddCardPlayed(S, R, X) { cardontable(S, R, X) } 
  { true }  AddBriscola(S, R) { briscola(S, R) } 
  { true }  RemoveCardPlayed(S, R, X) { not cardontable(S, R, X) } 

Beliefs:
  gatekeeper(gk).		/* we know who the gatekeeper is, for simplicity */
  dealer(d).
  currentturn(0).   /* the first turn is for the agent in postion 0 */
  
  getpoints(jack, X) :- X is 2.
  getpoints(queen, X) :- X is 3.
  getpoints(king, X) :- X is 4.
  getpoints(three, X) :- X is 10.
  getpoints(ace, X) :- X is 11.
  getpoints(Y, X) :- X is 0.
  
  //Get The Winner
  getwinner(Winner) :- cardontable(_, ace, Winner), !.
  getwinner(Winner) :- cardontable(_, three, Winner), !.
  getwinner(Winner) :- cardontable(_, king, Winner), !.
  getwinner(Winner) :- cardontable(_, queen, Winner), !.
  getwinner(Winner) :- cardontable(_, jack, Winner), !.
  getwinner(Winner) :- cardontable(_, seven, Winner), !.
  getwinner(Winner) :- cardontable(_, six, Winner), !.
  getwinner(Winner) :- cardontable(_, five, Winner), !.
  getwinner(Winner) :- cardontable(_, four, Winner), !.
  getwinner(Winner) :- cardontable(_, two, Winner), !.

Plans:
  @cardtable(enterAsNotary())	/* join the game as notary */

PC-rules:
  message(X, inform, _, _, registered(POS, Y)) <- true |
  {
    SetAssigned(POS, Y);	/* update belief about assigned sit */
    if B( POS = 4 ) then	/* if we believe we already assigned all the sits, then choose the dealer */
    { 
      /*@cardtable(chooseDealer(), D);*/
      /*SetDealer(D);*/
      send(d, inform, dealer(d))
    }
  }
  
 /**
  * --- BIDDING SCENARIO ---
  */
  message(X, inform, _, _, askfor(Pos)) <- true |
  {
    
    B(assigned(Pos, Y));
    if B( not playerpass(Y) ) then
    {
      send(X, inform, is(Y))
    }
    else
    {
      /*TODO: in general, here we must implement if there is some "jump" and if all them passed, 
      send the bidwinner message to the winner, but for the prototipe, this works. */
      send(X, inform, bidwinner(0))
    }
  }

  message(X, inform, _, _,  pass(Y)) <- true  | 
  {
    PlayerPass(X)
  }

 /**
  * --- DECLARE BRISCOLA SCENARIO ---
  */
  message(X, inform, _, _, declarebriscola(Briscola)) <- true | 
  {
    B( Briscola = [S, R] );
    AddBriscola(S, R);
    B( assigned(Pos, X) );
    if B( Pos = 0 ) then
    {
      B( assigned(1, P1));
      send(P1, inform, declarebriscola(Briscola, X));
      B( assigned(2, P2));
      send(P2, inform, declarebriscola(Briscola, X));
      B( assigned(3, P3));
      send(P3, inform, declarebriscola(Briscola, X));
      B( assigned(4, P4));
      send(P4, inform, declarebriscola(Briscola, X))
    };
    if B( Pos = 1 ) then
    {
      B( assigned(0, P1));
      send(P1, inform, declarebriscola(Briscola, X));
      B( assigned(2, P2));
      send(P2, inform, declarebriscola(Briscola, X));
      B( assigned(3, P3));
      send(P3, inform, declarebriscola(Briscola, X));
      B( assigned(4, P4));
      send(P4, inform, declarebriscola(Briscola, X))
    };
    if B( Pos = 2 ) then
    {
      B( assigned(0, P1));
      send(P1, inform, declarebriscola(Briscola, X));
      B( assigned(1, P2));
      send(P2, inform, declarebriscola(Briscola, X));
      B( assigned(3, P3));
      send(P3, inform, declarebriscola(Briscola, X));
      B( assigned(4, P4));
      send(P4, inform, declarebriscola(Briscola, X))
    };
    if B( Pos = 3 ) then
    {
      B( assigned(0, P1));
      send(P1, inform, declarebriscola(Briscola, X));
      B( assigned(1, P2));
      send(P2, inform, declarebriscola(Briscola, X));
      B( assigned(2, P3));
      send(P3, inform, declarebriscola(Briscola, X));
      B( assigned(4, P4));
      send(P4, inform, declarebriscola(Briscola, X))
    };
    if B( Pos = 4 ) then
    {
      B( assigned(0, P1));
      send(P1, inform, declarebriscola(Briscola, X));
      B( assigned(1, P2));
      send(P2, inform, declarebriscola(Briscola, X));
      B( assigned(2, P3));
      send(P3, inform, declarebriscola(Briscola, X));
      B( assigned(3, P4));
      send(P4, inform, declarebriscola(Briscola, X))
    };
    
    // START THE GAME!!!
    selectturn()
  }
  
 /**
  * --- PLAY SCENARIO ---
  */
  selectturn() <- currentturn(X) | 
  {
    if B( X = 5 ) then
    {
      RemoveTrun(X);
      UpdateTrun(0);
      B( assigned(0, P));
      print("Round over!");
      countpoints()
    }
    else
    {
      B( assigned(X, P));
      send(P, inform, yourturn(X));
      RemoveTrun(X);
      UpdateTrun(X + 1)
    }
  }
  
  event(cardPlayed(S, R, N), cardtable) <- true | 
  {
    //TODO add card played to can count points
    AddCardPlayed(S, R, N);
    selectturn()
  }
  
  countpoints() <- true |
  {      
     B( assigned(0, P0));
     B( cardontable(S0, R0, P0));
     B( getpoints(R0, X0));
     B( assigned(1, P1));
     B( cardontable(S1, R1, P1));
     B( getpoints(R1, X1));
     B( assigned(2, P2));
     B( cardontable(S2, R2, P2));
     B( getpoints(R2, X2));
     B( assigned(3, P3));
     B( cardontable(S3, R3, P3));
     B( getpoints(R3, X3));
     B( assigned(4, P4));
     B( cardontable(S4, R4, P4));
     B( getpoints(R4, X4));
     
     
     //Send point to the winner
     B( getwinner(W) );
     send(W, inform, yourscore( X0 + X1 + X2 + X3 + X4));
     @cardtable(updateScore(W, X0 + X1 + X2 + X3 + X4));
     
     //Clean table
     B( assigned(0, P0));
     B( cardontable(S0, R0, P0));
     RemoveCardPlayed(S0, R0, P0);
     B( assigned(1, P1));
     B( cardontable(S1, R1, P1));
     RemoveCardPlayed(S1, R1, P1);
     B( assigned(2, P2));
     B( cardontable(S2, R2, P2));
     RemoveCardPlayed(S2, R2, P2);
     B( assigned(3, P3));
     B( cardontable(S3, R3, P3));
     RemoveCardPlayed(S3, R3, P3);
     B( assigned(4, P4));
     B( cardontable(S4, R4, P4));
     RemoveCardPlayed(S4, R4, P4);
     
     //New round
     selectturn()
  }